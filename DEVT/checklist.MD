https://www.famicol.in/language_checklist.html 
<br>
Programming Language Checklist <br>
by Colin McMillen, Jason Reed, and Elly Fong-Jones, 2011-10-10.<br>
<br>
You appear to be advocating a new:<br>
[ ] functional  [ ] imperative  [ ] object-oriented  [ ] procedural [ ] stack-based<br>
[ ] "multi-paradigm"  [ ] lazy  [ ] eager  [ ] statically-typed  [ ] dynamically-typed<br>
[ ] pure  [ ] impure  [ ] non-hygienic  [ ] visual  [ ] beginner-friendly<br>
[ ] non-programmer-friendly  [ ] completely incomprehensible<br>
programming language.  Your language will not work.  Here is why it will not work.<br>
<br>
You appear to believe that:<br>
[ ] Syntax is what makes programming difficult<br>
[ ] Garbage collection is free                [ ] Computers have infinite memory<br>
[ ] Nobody really needs:<br>
    [ ] concurrency  [ ] a REPL  [ ] debugger support  [ ] IDE support  [ ] I/O<br>
    [ ] to interact with code not written in your language<br>
[ ] The entire world speaks 7-bit ASCII<br>
[ ] Scaling up to large software projects will be easy<br>
[ ] Convincing programmers to adopt a new language will be easy<br>
[ ] Convincing programmers to adopt a language-specific IDE will be easy<br>
[ ] Programmers love writing lots of boilerplate<br>
[ ] Specifying behaviors as "undefined" means that programmers won't rely on them<br>
[ ] "Spooky action at a distance" makes programming more fun<br>

Unfortunately, your language (has/lacks):<br>
[ ] comprehensible syntax  [ ] semicolons  [ ] significant whitespace  [ ] macros<br>
[ ] implicit type conversion  [ ] explicit casting  [ ] type inference<br>
[ ] goto  [ ] exceptions  [ ] closures  [ ] tail recursion  [ ] coroutines<br>
[ ] reflection  [ ] subtyping  [ ] multiple inheritance  [ ] operator overloading<br>
[ ] algebraic datatypes  [ ] recursive types  [ ] polymorphic types<br>
[ ] covariant array typing  [ ] monads  [ ] dependent types<br>
[ ] infix operators  [ ] nested comments  [ ] multi-line strings  [ ] regexes<br>
[ ] call-by-value  [ ] call-by-name  [ ] call-by-reference  [ ] call-cc<br>

The following philosophical objections apply:<br>
[ ] Programmers should not need to understand category theory to write "Hello, World!"<br>
[ ] Programmers should not develop RSI from writing "Hello, World!"<br>
[ ] The most significant program written in your language is its own compiler<br>
[ ] The most significant program written in your language isn't even its own compiler<br>
[ ] No language spec<br>
[ ] "The implementation is the spec"<br>
   [ ] The implementation is closed-source  [ ] covered by patents  [ ] not owned by you<br>
[ ] Your type system is unsound  [ ] Your language cannot be unambiguously parsed<br>
   [ ] a proof of same is attached<br>
   [ ] invoking this proof crashes the compiler<br>
[ ] The name of your language makes it impossible to find on Google<br>
[ ] Interpreted languages will never be as fast as C<br>
[ ] Compiled languages will never be "extensible"<br>
[ ] Writing a compiler that understands English is AI-complete<br>
[ ] Your language relies on an optimization which has never been shown possible<br>
[ ] There are less than 100 programmers on Earth smart enough to use your language<br>
[ ] ____________________________ takes exponential time<br>
[ ] ____________________________ is known to be undecidable<br>

Your implementation has the following flaws:<br>
[ ] CPUs do not work that way<br>
[ ] RAM does not work that way<br>
[ ] VMs do not work that way<br>
[ ] Compilers do not work that way<br>
[ ] Compilers cannot work that way<br>
[ ] Shift-reduce conflicts in parsing seem to be resolved using rand()<br>
[ ] You require the compiler to be present at runtime<br>
[ ] You require the language runtime to be present at compile-time<br>
[ ] Your compiler errors are completely inscrutable<br>
[ ] Dangerous behavior is only a warning<br>
[ ] The compiler crashes if you look at it funny<br>
[ ] The VM crashes if you look at it funny<br>
[ ] You don't seem to understand basic optimization techniques<br>
[ ] You don't seem to understand basic systems programming<br>
[ ] You don't seem to understand pointers<br>
[ ] You don't seem to understand functions<br>
<br>
Additionally, your marketing has the following problems:<br>
[ ] Unsupported claims of increased productivity<br>
[ ] Unsupported claims of greater "ease of use"<br>
[ ] Obviously rigged benchmarks<br>
   [ ] Graphics, simulation, or crypto benchmarks where your code just calls<br>
       handwritten assembly through your FFI<br>
   [ ] String-processing benchmarks where you just call PCRE<br>
   [ ] Matrix-math benchmarks where you just call BLAS<br>
[ ] Noone really believes that your language is faster than:<br>
    [ ] assembly  [ ] C  [ ] FORTRAN  [ ] Java  [ ] Ruby  [ ] Prolog<br>
[ ] Rejection of orthodox programming-language theory without justification<br>
[ ] Rejection of orthodox systems programming without justification<br>
[ ] Rejection of orthodox algorithmic theory without justification<br>
[ ] Rejection of basic computer science without justification<br>

Taking the wider ecosystem into account, I would like to note that:<br>
[ ] Your complex sample code would be one line in: _______________________<br>
[ ] We already have an unsafe imperative language<br>
[ ] We already have a safe imperative OO language<br>
[ ] We already have a safe statically-typed eager functional language<br>
[ ] You have reinvented Lisp but worse<br>
[ ] You have reinvented Javascript but worse<br>
[ ] You have reinvented Java but worse<br>
[ ] You have reinvented C++ but worse<br>
[ ] You have reinvented PHP but worse<br>
[ ] You have reinvented PHP better, but that's still no justification<br>
[ ] You have reinvented Brainfuck but non-ironically<br>

In conclusion, this is what I think of you:<br>
[ ] You have some interesting ideas, but this won't fly.<br>
[ ] This is a bad language, and you should feel bad for inventing it.<br>
[ ] Programming in this language is an adequate punishment for inventing it.<br>
